<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DSYING</title>
  
  <subtitle>DingSheng&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-26T03:40:44.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css之—堆叠上下文</title>
    <link href="http://yoursite.com/2018/08/26/css-%E5%A0%86%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://yoursite.com/2018/08/26/css-堆叠上下文/</id>
    <published>2018-08-26T03:40:44.000Z</published>
    <updated>2018-08-26T03:40:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="默认堆叠顺序"><a href="#默认堆叠顺序" class="headerlink" title="默认堆叠顺序"></a>默认堆叠顺序</h2><p><a href="http://jsrun.net/pCgKp/edit" target="_blank" rel="noopener">demo地址</a><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/165649dbf603d6e8?w=2020&amp;h=1202&amp;f=png&amp;s=590929" alt=""></p><ul><li>background</li><li>border</li><li>块级</li><li>浮动</li><li>内联</li><li>z-index: 0</li><li>z-index: +</li></ul><p>如果是兄弟元素重叠，那么后面的盖在前面的身上</p><h3 id="不含z-index的堆叠-Stacking-without-z-index"><a href="#不含z-index的堆叠-Stacking-without-z-index" class="headerlink" title="不含z-index的堆叠(Stacking without z-index)"></a>不含z-index的堆叠(Stacking without z-index)</h3><ul><li><a href="http://jsrun.net/ECgKp/edit" target="_blank" rel="noopener">demo代码</a></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/Stacking_without_z-index" target="_blank" rel="noopener">MDN详解</a><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/165670dc9e34b107?w=1546&amp;h=758&amp;f=png&amp;s=81557" alt=""><br>当没有元素包含z-index属性时，元素按照如下顺序堆叠（从底到顶顺序）：</p></li><li><p>根元素的背景和边界</p></li><li>普通流(无定位)里的块元素(没有position或者position:static;) 按HTML中的出现顺序堆叠</li><li>定位元素按HTML中的出现顺序堆叠</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/165671af979cd28c?w=1834&amp;h=384&amp;f=png&amp;s=143774" alt=""></p><h3 id="float元素的层叠-Stacking-and-float"><a href="#float元素的层叠-Stacking-and-float" class="headerlink" title="float元素的层叠(Stacking and float)"></a>float元素的层叠(Stacking and float)</h3><ul><li><a href="http://jsrun.net/7CgKp/edit" target="_blank" rel="noopener">demo地址</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/Stacking_and_float" target="_blank" rel="noopener">MDN详解</a></li></ul><p>小提示：本案例MDN中的css设置了opacity: 0.7，透明度属性会生成堆叠上下文，造成误解，此处先不设置该属性<br><img src="https://user-gold-cdn.xitu.io/2018/8/23/165673e58d6f180c?w=1542&amp;h=598&amp;f=png&amp;s=63282" alt=""></p><ul><li>根元素的背景与边框</li><li>位于普通流中的后代块元素按照它们在 HTML 中出现的顺序层叠</li><li>浮动块元素</li><li>常规流中的后代行内元素</li><li>后代中的定位元素按照它们在 HTML 中出现的顺序层叠</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/1656745ad86e9ac0?w=2918&amp;h=578&amp;f=png&amp;s=310583" alt=""></p><h3 id="使用-z-index-Add-z-index"><a href="#使用-z-index-Add-z-index" class="headerlink" title="使用 z-index(Add z-index)"></a>使用 z-index(Add z-index)</h3><p>在第一个例子 Stacking without z-index 中， 我们描述了<strong>默认的摆放顺序</strong>。 当你需要指定不同的排列顺序时， 只要给元素指定一个z-index的数值就可以了</p><p>该属性必须是整数(正负均可)， 它体现了元素在z轴的位置。 如果你对z轴体系不了解， 你也可以把它理解成“层叠”， 每个层都有一个顺序数， <strong>顺序数大的层在上面， 小的在下面</strong></p><p><strong>注意！z-index只对指定了 positioned(即position不为static的)属性的元素有效。</strong></p><ul><li>底层: 距离观察者最远</li><li>…</li><li>-3 层</li><li>-2 层</li><li>-1 层</li><li>0 层 默认层</li><li>1 层</li><li>2 层</li><li>3 层</li><li>…</li><li><p>顶部: 最接近观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当没有指定z-index的时候， 所有元素都在会被渲染在默认层(0层)</span><br><span class="line">当多个元素的z-index属性相同的时候(在同一个层里面)，那么将按照 Stacking without z-index 中描述的规则进行布局。</span><br></pre></td></tr></table></figure></li><li><p><a href="http://jsrun.net/FCgKp/edit" target="_blank" rel="noopener">demo地址</a></p></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/Adding_z-index" target="_blank" rel="noopener">MDN详解</a></li></ul><p>元素div#5 的z-index无效， 因为他没有被指定position属性。</p><p><strong>注意! positioned元素，z-index值越大 越靠近用户，显示在上面</strong><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/1656753363dccd82?w=1548&amp;h=776&amp;f=png&amp;s=94240" alt=""></p><h2 id="层叠上下文-The-stacking-context"><a href="#层叠上下文-The-stacking-context" class="headerlink" title="层叠上下文(The stacking context)"></a>层叠上下文(The stacking context)</h2><p>文档中的层叠上下文由满足以下任意一个条件的元素形成</p><ul><li>根元素 (HTML),</li><li>z-index 值不为 “auto”的 绝对/相对定位，</li><li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li><li>transform 属性值不为 “none”的元素，</li><li>mix-blend-mode 属性值不为 “normal”的元素，</li><li>filter值不为“none”的元素，</li><li>perspective值不为“none”的元素，</li><li>isolation 属性被设置为 “isolate”的元素，</li><li>position: fixed</li><li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）</li><li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li></ul><p>符合上述任一条件，就会生成一个层叠上下文。</p><p><strong>我个人将层叠上下文理解为类似于js中作用域的一种环境</strong>，</p><ul><li>上下文可以包含于被包含，</li><li>上下文内部元素如何排序与外部无关</li><li>子元素的 z-index 值只在父级层叠上下文中有意义</li></ul><ul><li><a href="http://jsrun.net/xCgKp/edit" target="_blank" rel="noopener">demo地址</a></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">MDN详解</a><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/1656760bc62af8a8?w=2046&amp;h=802&amp;f=png&amp;s=143378" alt=""></p></li><li><p>Root(html标签)                    </p><ul><li>Div#1                         ——————-&gt;z-index:5                     </li><li>Div#2                         ——————-&gt;z-index:2</li><li>Div#3                         ——————-&gt;z-index:4<ul><li>Div#4                         ——————-&gt;z-index:6</li><li>Div#5                         ——————-&gt;z-index:1</li><li>Div#6                         ——————-&gt;z-index:3</li></ul></li></ul></li></ul><p>注意 DIV#4，DIV #5 和 DIV #6 是 DIV #3 的子元素，所以它们的层叠完全在 DIV #3 中被处理。一旦 DIV #3 中的层叠和渲染处理完成，DIV #3 元素作为一个整体传递给 root 元素，并相对兄弟元素层叠</p><p>上面一段话可以概括成<strong>z-index不会垮层级去做比较</strong></p><p>分辨出层叠的元素在 Z 轴上的渲染顺序的一个简单方法是将它们想象成一系列的版本号，子元素是其父元素版本号之下的次要版本。</p><ul><li>Root</li><li>DIV #2 - z-index 为 2</li><li>DIV #3 - z-index 为 4<ul><li>DIV #5 - z-index 为 1，在一个 z-index 为 4 的元素内层叠，所以渲染次序为 4.1</li><li>DIV #6 - z-index 为 3，在一个 z-index 为 4 的元素内层叠，所以渲染次序为 4.3</li><li>DIV #4 - z-index 为 6，在一个 z-index 为 4 的元素内层叠，所以渲染次序为 4.6</li></ul></li><li>DIV #1 - z-index 为 5</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/1656774c90fef052?w=2604&amp;h=908&amp;f=png&amp;s=353467" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;默认堆叠顺序&quot;&gt;&lt;a href=&quot;#默认堆叠顺序&quot; class=&quot;headerlink&quot; title=&quot;默认堆叠顺序&quot;&gt;&lt;/a&gt;默认堆叠顺序&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jsrun.net/pCgKp/edit&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css之—flex布局</title>
    <link href="http://yoursite.com/2018/08/26/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/08/26/flex布局/</id>
    <published>2018-08-26T03:39:00.000Z</published>
    <updated>2018-08-26T03:39:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>为方便理解flex各属性，写了一个flex的属性调试页面。<a href="http://jsrun.net/LGgKp" target="_blank" rel="noopener">地址</a></p><p>通过一个小游戏来测试你对flex的掌握。<a href="http://flexboxfroggy.com/#zh-cn" target="_blank" rel="noopener">青蛙</a></p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e64534453f25?w=1100&amp;h=638&amp;f=png&amp;s=108116" alt=""><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><h2 id="display-flex"><a href="#display-flex" class="headerlink" title="display:flex"></a>display:flex</h2><p>一个容器设置了display:flex;属性就定义了一个flex容器，它的直接子元素会接受这个flex环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex; /* or inline-flex */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e562baf5bde5?w=638&amp;h=164&amp;f=png&amp;s=3643" alt=""><br>设置或检索伸缩盒对象的子元素在父容器中的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>row 默认值，水平从左到右</li><li>row-reverse 水平从右到左</li><li>column 垂直从上到下</li><li>column-reverse 垂直从下到上</li></ul><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e5855b91f3b2?w=622&amp;h=216&amp;f=png&amp;s=7515" alt=""><br>设置或检索弹性盒模型对象的子元素超出父容器时是否换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>nowrap 默认值，不换行</li><li>wrap 换行</li><li>wrap-reverse 换行，并且颠倒行顺序</li></ul><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e5989d4ff6de?w=640&amp;h=726&amp;f=png&amp;s=31212" alt=""><br>设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式，当弹性盒里一行上的所有子元素都不能伸缩或已经达到其最大值时，这一属性可协助对多余的空间进行分配。当元素溢出某行时，这一属性同样会在对齐上进行控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>flex-start 默认值、弹性盒子元素将向行起始位置对齐</p></li><li><p>flex-end 弹性盒子元素将向行结束位置对齐</p></li><li><p>center弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐</p></li><li><p>space-between 弹性盒子元素会平均地分布在行里</p></li><li><p>space-around 弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半</p></li></ul><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e5ac4759759d?w=620&amp;h=752&amp;f=png&amp;s=32082" alt=""><br>设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>flex-start 弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</p></li><li><p>flex-end 弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</p></li><li><p>center 弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</p></li><li><p>baseline 如弹性盒子元素的行内轴与侧轴为同一条，则该值与flex-start等效。其它情况下，该值将参与基线对齐。</p></li><li><p>stretch 如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制</p></li></ul><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e5c05d8e56cf?w=620&amp;h=744&amp;f=png&amp;s=30668" alt=""><br>设置或检索弹性盒堆叠伸缩行的对齐方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>flex-start 各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行。</p></li><li><p>flex-end 各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行。</p></li><li><p>center 各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一行之间的距离相等。</p></li><li><p>space-between 各行在弹性盒容器中平均分布。第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等。</p></li><li><p>space-around 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半。</p></li><li><p>stretch 各行将会伸展以占用剩余的空间。剩余空间被所有行平分，以扩大它们的侧轴尺寸</p></li></ul><h1 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h1><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e5d784273d50?w=214&amp;h=144&amp;f=png&amp;s=3153" alt=""><br>在默认情况下flex order会按照书写顺训呈现，可以通过order属性改变，数值小的在前面，还可以是负数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p>用于<strong>瓜分</strong>父容器的<strong>剩余空间</strong><br><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e5e33183c282?w=798&amp;h=198&amp;f=png&amp;s=5866" alt=""><br>设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>设置或检索弹性盒伸缩基准值，如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex-grow, flex-shrink,flex-basis 的缩写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e60e146fe30c?w=618&amp;h=270&amp;f=png&amp;s=11603" alt=""><br>设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器align-items的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="深入理解-flex-grow-flex-shrink"><a href="#深入理解-flex-grow-flex-shrink" class="headerlink" title="深入理解 flex-grow/flex-shrink"></a>深入理解 flex-grow/flex-shrink</h1><h2 id="flex-grow-1"><a href="#flex-grow-1" class="headerlink" title="flex-grow"></a>flex-grow</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e62b88ad5b7a?w=1096&amp;h=596&amp;f=png&amp;s=124725" alt=""><br>容器的宽度为400px, 子项1的占用的基础空间(flex-basis)为50px，子项2占用的基础空间是70px，子项3占用基础空间是100px，剩余空间为 400-50-70-100 = 180px。 其中子项1的flex-grow: 0(未设置默认为0)， 子项2flex-grow: 2，子项3flex-grow: 1，剩余空间分成3份，子项2占2份(120px)，子项3占1份(60px)。所以 子项1真实的占用空间为: 50+0 = 50px， 子项2真实的占用空间为: 70+120 = 190px， 子项3真实的占用空间为: 100+60 = 160px。</p><h2 id="flex-shrink-1"><a href="#flex-shrink-1" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>用来“吸收”超出的空间</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/16/1653e634c4971388?w=1078&amp;h=592&amp;f=png&amp;s=126037" alt=""><br>容器的宽度为400px, 子项1的占用的基准空间(flex-basis)为250px，子项2占用的基准空间是150px，子项3占用基准空间是100px，总基准空间为 250+150+100=500px。容器放不下，多出来的空间需要被每个子项根据自己设置的flex-shrink 进行吸收。 子项1的flex-shrink: 1(未设置默认为1)， 子项2 flex-shrink: 2，子项3 flex-shrink: 2。子项1需要吸收的的空间为 (250<em>1)/(250</em>1+150<em>2+100</em>2) <em> 100 = 33.33px，子项1真实的空间为 250-33.33 = 216.67px。同理子项2吸收的空间为(150</em>2)/(250<em>1+150</em>2+100<em>2) </em> 100=40px，子项2真实空间为 150-40 = 110px。子项3吸收的空间为(100<em>2)/(250</em>1+150<em>2+100</em>2) * 100 = 26.67px，真实的空间为100-26.67=73.33px。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h1&gt;&lt;p&gt;为方便理解flex各属性，写了一个flex的属性调试页面。&lt;a href=&quot;http://jsrun.net/LGgKp&quot; 
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>javascript之—事件</title>
    <link href="http://yoursite.com/2018/08/26/%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/08/26/事件/</id>
    <published>2018-08-26T03:37:57.000Z</published>
    <updated>2018-08-26T03:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>说到JavaScript的事件，就会牵扯到事件的捕获与冒泡两个概念。</p><h2 id="通过代码去理解"><a href="#通过代码去理解" class="headerlink" title="通过代码去理解"></a>通过代码去理解</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"grand1"</span>&gt;</span></span><br><span class="line">    爷爷</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent1"</span>&gt;</span></span><br><span class="line">        父亲</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child1"</span>&gt;</span></span><br><span class="line">            儿子</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">10px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grand1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1爷爷'</span>) </span><br><span class="line">&#125;)</span><br><span class="line">parent1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2父亲'</span>) </span><br><span class="line">&#125;)</span><br><span class="line">child1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3儿子'</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/1652edf37f80b041?w=1276&amp;h=300&amp;f=png&amp;s=13859" alt=""><br>请思考几个问题</p><ul><li>1 当我点击儿子的时候，我是否点击了父亲和爷爷?<ul><li>答案：yes 我点了你的鼻子你说我有没有点到你的脸</li></ul></li><li><p>2 当我点击儿子的时候，三个函数是否调用?</p><ul><li>答案：yes</li></ul></li><li><p>3 三个函数的调用顺序  3 2 1 or 1 2 3?</p><ul><li>答案：addEventListener(‘click’,function(){}，true/falsey)<br>的第三个参数为 false时 输出顺序  儿子-&gt;父亲-&gt;爷爷<br>如果第三个参数为 true  输出顺序  爷爷-&gt;父亲-&gt;儿子</li></ul></li></ul><p><a href="http://jsrun.net/SJgKp/edit" target="_blank" rel="noopener">demo效果</a></p><h2 id="通过文字描述理解"><a href="#通过文字描述理解" class="headerlink" title="通过文字描述理解"></a>通过文字描述理解</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/1652ee661b0cd58c?w=3318&amp;h=1836&amp;f=jpeg&amp;s=289395" alt=""></p><ul><li>当鼠标点击儿子时，</li><li>浏览器会县从上往下问，你孩子被人打了，你管不管啊？这个阶段叫捕获</li><li>然后儿子会从下往上问，爸，你儿子我被人打了，你问不问啊？问完再问爷爷。这个阶段叫冒泡</li><li>那一个事件到底是在捕获阶段还是冒泡阶段执行呢？由addEventListener函数的第三个参数决定</li><li>true:捕获阶段 | false:冒泡阶段</li></ul><p><a href="http://jsrun.net/ixgKp/edit" target="_blank" rel="noopener">demo效果</a></p><h3 id="两种型号"><a href="#两种型号" class="headerlink" title="两种型号"></a>两种型号</h3><p>毫不奇怪，在过去的糟糕时期，Netscape和微软得出了不同的结论</p><ul><li>Netscape表示<strong>爷爷元素</strong>上的事件首先发生。这称为事件捕获。</li><li>Microsoft坚持认为<strong>儿子元素</strong>上的事件优先。这称为事件冒泡。</li></ul><p>两个事件顺序完全相反。Explorer仅支持事件冒泡。Mozilla，Opera 7和Konqueror都支持这两种方式。旧版Opera和iCab都不支持。</p><h3 id="W3C型号"><a href="#W3C型号" class="headerlink" title="W3C型号"></a>W3C型号</h3><p>W3C非常明智地决定在这场斗争中占据中间位置。首<strong>先捕获</strong>在DOM中发生的任何事件， 直到它到达<strong>目标元素</strong>，然后<strong>再次冒泡</strong></p><p>Web开发人员可以选择是在捕获阶段还是在冒泡阶段注册事件处理程序。这是通过addEventListener() 的最后一个参数决定的。如果它的最后一个参数是</p><ul><li>true 则为捕获阶段设置的事件处理程序</li><li>false ，则为冒泡阶段设置事件处理程序</li></ul><h2 id="通过MDN去理解"><a href="#通过MDN去理解" class="headerlink" title="通过MDN去理解"></a>通过MDN去理解</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/19/1655133e5664b0ea?w=647&amp;h=594&amp;f=png&amp;s=100800" alt=""></p><ul><li>1 代表捕获阶段</li><li>2 代表事件目标</li><li>3 代表冒泡阶段</li></ul><h3 id="注册事件监听器"><a href="#注册事件监听器" class="headerlink" title="注册事件监听器"></a>注册事件监听器</h3><ul><li><p>EventTarget.addEventListener</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用</span></span><br><span class="line">myButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'Hello world'</span>);&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>HTML 属性</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--我们应该避免使用这种方式。因为它会使标记数量变大，而可读性却较差。 内容/结构 和 行为之间没有很好的分离，使得在处理bug时非常困难--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello world!')"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>DOM 元素属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种方法的问题在于每个元素和事件只能设置一个处理函数</span></span><br><span class="line">myButton.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;alert(<span class="string">'Hello world'</span>);&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">addEventListener()</a></h3><p>语法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target .addEventListener（type，listener [，options ]）;</span><br><span class="line">target .addEventListener（type，listener [，useCapture ]）;</span><br></pre></td></tr></table></figure></p><ul><li>type  一个区分大小写的字符串，表示要侦听的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">事件类型</a></li><li>listener 当发生指定类型的事件时接收通知（实现接口的对象）的对象,比如JavaScript 函数</li><li>useCapture 是否使用捕获 true/false  默认为false 表明该事件实在捕获阶段还是冒泡阶段触发</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event)  </span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><strong>click</strong> : 事件类型的一种(鼠标点击事件)</p><p><strong>event</strong> : 监听器回调函数的参数</p><ul><li>event.currentTarget  对当前注册的事件目标的引用</li><li>event.preventDefault() 取消事件（如果可取消)</li><li>event.stopPropagation() 阻止事件在DOM中进一步传播。</li></ul><p><strong>true</strong> : true表示该事件 使用了捕获机制，该参数默认为false</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说到JavaScript的事件，就会牵扯到事件的捕获与冒泡两个概念。&lt;/p&gt;
&lt;h2 id=&quot;通过代码去理解&quot;&gt;&lt;a href=&quot;#通过代码去理解&quot; class=&quot;headerlink&quot; title=&quot;通过代码去理解&quot;&gt;&lt;/a&gt;通过代码去理解&lt;/h2&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript之—Scope</title>
    <link href="http://yoursite.com/2018/08/26/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/08/26/作用域/</id>
    <published>2018-08-26T03:36:56.000Z</published>
    <updated>2018-08-26T03:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章内容大量引用了<br><a href="http://javascript.ruanyifeng.com/grammar/function.html" target="_blank" rel="noopener">阮一峰老师的博客</a><br>和<a href="https://weibo.com/ttarticle/p/show?id=2309404266092519423449" target="_blank" rel="noopener">方应杭老师的文章</a></p><h1 id="js的作用域"><a href="#js的作用域" class="headerlink" title="js的作用域"></a>js的作用域</h1><p>作用域(scope)指的是变量存在的范围。在ES5的规范中，JavaScript只有两种作用域，<br>一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取。<br>一种是函数作用域，变量只在函数内部存在。<br>ES6中又引入了块级作用域的概念。</p><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>函数外部的变量就是全局作用域，它可以在函数内部读取<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>上面的代码表明，函数f内部可以读取全局变量v</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>在函数内部定义的变量，外部无法读取，称为局部变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">v <span class="comment">//Uncaught ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取</p><h1 id="与作用域相关的知识点"><a href="#与作用域相关的知识点" class="headerlink" title="与作用域相关的知识点"></a>与作用域相关的知识点</h1><h2 id="1-立即执行函数"><a href="#1-立即执行函数" class="headerlink" title="1 立即执行函数"></a>1 立即执行函数</h2><p>​​​这是 JS 中的一个常见概念，面试时经常会被问到，请「用自己的语言」简述</p><ul><li>立即执行函数是什么</li><li>立即执行函数有什么用途</li></ul><h3 id="1-1立即执行函数是什么"><a href="#1-1立即执行函数是什么" class="headerlink" title="1.1立即执行函数是什么"></a>1.1立即执行函数是什么</h3><ul><li>声明一个匿名函数</li><li>马上调用这个匿名函数</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/16505557dd298b37?w=1464&amp;h=528&amp;f=jpeg&amp;s=62868" alt=""><br>上面是一个典型的立即执行函数。</p><ul><li>首先声明一个匿名函数 function(){alert(‘我是匿名函数’)}。</li><li>然后在匿名函数后面接一对括号 ()，调用这个匿名函数。</li></ul><p><em>那么为什么还要用另一对括号把匿名函数包起来呢？</em><br>其实是为了兼容 JS 的语法。<br>如果我们不加另一对括号，直接写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'我是匿名函数'</span>)&#125;()</span><br></pre></td></tr></table></figure></p><p>​浏览器会报语法错误。想要通过浏览器的语法检查，必须加点小东西，比如下面几种</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650555b82dc5c1a?w=1242&amp;h=364&amp;f=jpeg&amp;s=94837" alt=""></p><h3 id="1-2立即执行函数有什么用"><a href="#1-2立即执行函数有什么用" class="headerlink" title="1.2立即执行函数有什么用"></a>1.2立即执行函数有什么用</h3><p>只有一个作用：创建一个独立的作用域。<br>这个作用域里面的变量，外面访问不到（即避免「变量污染」）。<br>以一个著名的面试题为例：<br><img src="https://user-gold-cdn.xitu.io/2018/8/4/1650555ed5e9c34b?w=1114&amp;h=314&amp;f=jpeg&amp;s=37179" alt=""><br>​为什么 alert 的总是 6 呢，因为 i 是贯穿整个作用域的，而不是给每个 li 分配了一个 i，如下：<br><img src="https://user-gold-cdn.xitu.io/2018/8/4/165055627a133a21?w=1424&amp;h=360&amp;f=jpeg&amp;s=58936" alt=""><br>那么怎么解决这个问题呢？用立即执行函数给每个 li 创造一个独立作用域即可（当然还有其他办法）：<br><img src="https://user-gold-cdn.xitu.io/2018/8/4/165055651447946d?w=1070&amp;h=392&amp;f=jpeg&amp;s=36315" alt=""><br>​​在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。<br>i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。<br>以上，就是立即执行函数的基本概念。</p><h2 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2 闭包"></a>2 闭包</h2><ul><li>什么是闭包</li><li>闭包的作用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line">v <span class="comment">//Uncaught ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure><p>f1函数内的变量v ，函数外无法读取</p><p><strong>如果某些场景确实需要读取函数内的变量，如何办到？</strong><br>答案：在函数内部，再定义一个函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="number">99</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v1 = f1();</span><br><span class="line"><span class="built_in">console</span>.log(v1())</span><br></pre></td></tr></table></figure></p><p>上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立</p><h3 id="2-1什么是闭包"><a href="#2-1什么是闭包" class="headerlink" title="2.1什么是闭包"></a>2.1什么是闭包</h3><ul><li>闭包就是函数f2，即能够读取其他函数内部变量的函数。</li><li>在js中只有函数内部的子函数才能读取内部的变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”</li><li><strong>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</strong><h3 id="2-2闭包由什么用"><a href="#2-2闭包由什么用" class="headerlink" title="2.2闭包由什么用"></a>2.2闭包由什么用</h3></li><li>读取其它函数内部的变量</li><li>让这些变量始终保持在内存中(即闭包可以使得它诞生环境一直存在)</li></ul><p>请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p><p><strong>为什么会这样呢?</strong> 原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor,更确切的说是依赖createIncrementor的局部变量start，因此inc始终在内存中，不会在调用结束后，被垃圾回收机制回收</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章内容大量引用了&lt;br&gt;&lt;a href=&quot;http://javascript.ruanyifeng.com/grammar/function.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰老师的博客&lt;/a&gt;&lt;br&gt;和&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript之—Function</title>
    <link href="http://yoursite.com/2018/08/26/function/"/>
    <id>http://yoursite.com/2018/08/26/function/</id>
    <published>2018-08-26T03:35:05.000Z</published>
    <updated>2018-08-26T03:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建函数的5中方式"><a href="#创建函数的5中方式" class="headerlink" title="创建函数的5中方式"></a>创建函数的5中方式</h1><p>1 具名函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">f.name <span class="comment">// f</span></span><br></pre></td></tr></table></figure></p><p>2 匿名函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f</span><br><span class="line">f = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">f.name <span class="comment">// f</span></span><br></pre></td></tr></table></figure></p><p>3 具名函数赋值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f</span><br><span class="line"> f = <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">x,y</span>)</span>&#123; </span><br><span class="line">     <span class="keyword">return</span> x+y</span><br><span class="line">  &#125;</span><br><span class="line">  f.name <span class="comment">// f2  what fuck 什么鬼？为啥是f2</span></span><br><span class="line">  <span class="built_in">console</span>.log(f2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>4 Function构造函数 window.Function<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'return x+y'</span>)</span><br><span class="line">f.name <span class="comment">// anonymous（匿名的意思）</span></span><br></pre></td></tr></table></figure></p><p>5 箭头函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x+y</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//如果&#123;&#125;内只有一句话 则花括号和return可以同时省略</span></span><br><span class="line"> <span class="keyword">var</span> sum = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y</span><br><span class="line"> <span class="comment">//如果（）内只有一个参数，则可以省略括号</span></span><br><span class="line"> <span class="keyword">var</span> n2 = <span class="function"><span class="params">n</span> =&gt;</span> n*n</span><br></pre></td></tr></table></figure></p><h1 id="函数的内存图"><a href="#函数的内存图" class="headerlink" title="函数的内存图"></a>函数的内存图</h1><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164eb6ed5ec2d223?w=2978&amp;h=916&amp;f=jpeg&amp;s=153040" alt=""><br>我们不妨模拟一下：<br><strong>函数调用的过程其实就是eval（函数体）的过程</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = &#123;&#125;</span><br><span class="line">f.param = [<span class="string">'x'</span>,<span class="string">'y'</span>]</span><br><span class="line">f.fbody = <span class="string">'console.log(111)'</span></span><br><span class="line">f.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(f.fbody)</span><br><span class="line">&#125;</span><br><span class="line">f.call() <span class="comment">// 111</span></span><br></pre></td></tr></table></figure></p><p>f 是一个对象，把函数体封装成一个属性，通过f.call()去执行这个函数的函数体</p><h1 id="scope-作用域"><a href="#scope-作用域" class="headerlink" title="scope 作用域"></a>scope 作用域</h1><p>javascript在读取代码时会先将代码转换成 <em>语法树</em></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/9/1651d9a6faf8abda?w=701&amp;h=347&amp;f=png&amp;s=177440" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/7/30/164eb6de96d668c5?w=3026&amp;h=1908&amp;f=jpeg&amp;s=275118" alt=""></p><p><strong>是否听过这么一句话?</strong></p><p>如果在声明变量的时候不加var 你就是在声明全局变量<br>例如：a = 3 </p><ol><li>优先认为这是一个赋值语句</li><li>它会在当前作用域寻找 a的声明,如果没有，沿着作用域树向上查找，如果全局scope也没有变量a ,只能退而求其次，先声明变量a 再执行 a=3 </li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164eb6e2baf8e240?w=3030&amp;h=1830&amp;f=jpeg&amp;s=307312" alt=""></p><h2 id="就近原则"><a href="#就近原则" class="headerlink" title="就近原则"></a>就近原则</h2><p><strong>javascript 中作用域分为 全局作用域和函数作用域</strong><br>只要有函数，就存在其对应的作用域<br>寻找一个变量的作用域 遵循 <strong>就近原则</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164eb6e4f7a3c817?w=1352&amp;h=1728&amp;f=jpeg&amp;s=154343" alt=""></p><h1 id="this-和-arguments"><a href="#this-和-arguments" class="headerlink" title="this 和 arguments"></a>this 和 arguments</h1><ul><li><p>this的值到底是什么？ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前函数运行时所在的环境(即this的指向),也可以说 当前函数运行时所处的对象</span><br></pre></td></tr></table></figure></li><li><p>arguments是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前函数的参数集合，它是一个类数组（likeArray）</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line">obj.foo() <span class="comment">// 打印出的 this 是 obj</span></span><br><span class="line">bar() <span class="comment">// 打印出的 this 是 window</span></span><br></pre></td></tr></table></figure><p>最后两行函数的值为什么不一样?</p><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"><span class="comment">//第一种调用 语法糖</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br><span class="line"><span class="comment">//第二种调用 硬核玩家通过call调用函数 函数真正的使用方式应该是第二种</span></span><br><span class="line">f.call(<span class="literal">undefined</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向</strong></p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisValue, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></p><p><strong>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() === <span class="built_in">window</span> <span class="comment">// true  全局环境运行函数f时，this指向全局环境（浏览器为window对象）</span></span><br><span class="line">f.call(obj) === obj <span class="comment">// true call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f</span></span><br></pre></td></tr></table></figure><p>call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局(window)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">n</span>: <span class="number">456</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.n);</span><br><span class="line">&#125;</span><br><span class="line">a.call() <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="literal">null</span>) <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="literal">undefined</span>) <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="built_in">window</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.call(obj) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure></p><p>call方法还可以接受多个参数,第一个参数为this,后面的所有参数组成这个方法的参数集合arguments,它是一个伪数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">fn1.call(<span class="built_in">window</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//this指向window arguments：[0:'1',1:'2',length:'2']</span></span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164eb6d456ccb44c?w=2728&amp;h=1324&amp;f=jpeg&amp;s=174167" alt=""></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是：</p><ul><li>它接收一个数组作为函数执行时的参数</li></ul><p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisValue, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">f.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>]) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><ul><li>bind方法用于将函数体内的this绑定到某个对象，<strong>然后返回一个新函数</strong>。</li><li>bind方法的参数就是所要绑定this的对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = counter.inc;</span><br><span class="line">func1();</span><br><span class="line">counter.count <span class="comment">// 0 this指向window </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func2 = counter.inc.bind(counter);</span><br><span class="line">func2();</span><br><span class="line">counter.count <span class="comment">// 1 通过bind绑定 this指向counter</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6中新出的函数创建方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只有一个参数时，可以不用()将参数括起来</span></span><br><span class="line"><span class="keyword">let</span> log = <span class="function"><span class="params">a</span> =&gt;</span> a*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法体只有一句话时 可以不用&#123;&#125;将方法体括起来，也可以省略 return</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s = x+y;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法体有多行时，需要用&#123;&#125;将方法体括起来</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = x+y;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h2><p>箭头函数内部的this是词法作用域，由上下文确定.也就是说箭头函数所处的作用域就是this的指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;.bind(&#123;<span class="attr">name</span>:<span class="string">'dsying'</span>&#125;),<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//输出：&#123;name:'dsying'&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;.bind(&#123;<span class="attr">name</span>:<span class="string">'dsying'</span>&#125;),<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;name:'dsying'&#125;</span></span><br><span class="line"><span class="comment">//window</span></span><br></pre></td></tr></table></figure><p>要想让第二个定时器也打印出{name:’dsying’}<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>),<span class="number">1000</span>)</span><br><span class="line">&#125;.bind(&#123;<span class="attr">name</span>:<span class="string">'dsying'</span>&#125;),<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;name:'dsying'&#125;</span></span><br><span class="line"><span class="comment">//&#123;name:'dsying'&#125;</span></span><br></pre></td></tr></table></figure></p><p>由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>),<span class="number">1000</span>)</span><br><span class="line">&#125;.bind(&#123;<span class="attr">name</span>:<span class="string">'dsying'</span>&#125;),<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;name:'dsying'&#125;</span></span><br><span class="line"><span class="comment">//&#123;name:'dsying'&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创建函数的5中方式&quot;&gt;&lt;a href=&quot;#创建函数的5中方式&quot; class=&quot;headerlink&quot; title=&quot;创建函数的5中方式&quot;&gt;&lt;/a&gt;创建函数的5中方式&lt;/h1&gt;&lt;p&gt;1 具名函数&lt;br&gt;&lt;figure class=&quot;highlight javascr
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript之—DOM</title>
    <link href="http://yoursite.com/2018/08/26/DOM/"/>
    <id>http://yoursite.com/2018/08/26/DOM/</id>
    <published>2018-08-26T03:33:38.000Z</published>
    <updated>2018-08-26T03:34:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h2><pre><code>* DOM是js操作网页的接口* DOM是一棵由node节点构成的树* DOM(Document Object Model)文档对象模型， 文档与对象之间建立的模型映射关系</code></pre><h2 id="什么是node"><a href="#什么是node" class="headerlink" title="什么是node"></a>什么是node</h2><pre><code>* 组成DOM树的最小单位叫做节点(node)* 每个节点可以看做是DOM树的一片叶子</code></pre><p><strong>Node常见的5种类型(共7种)</strong><br>| |  Document|  Element|  Attribute|  Text|  Comment|<br>| — | — | — | — | — | — |<br>| 说明| 文档节点| 元素节点| 属性节点| 文本节点| 注释节点|<br>| nodeType| 9| 1| 2| 3| 8|<br>| nodeName| #document| 大写标签名(DIV)| 属性名| #text| #comment|<br>|   nodeValue| null| null| null| 值| 值|</p><p>浏览器提供一个原生的节点对象 <a href="https://wangdoc.com/javascript/dom/node.html" target="_blank" rel="noopener"><em>Node</em></a> ，上面这七种节点都继承了Node，因此具有一些共同的属性和方法</p><h2 id="如何理解DOM是一棵树"><a href="#如何理解DOM是一棵树" class="headerlink" title="如何理解DOM是一棵树"></a>如何理解DOM是一棵树</h2><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164eb6b95ad64e59?w=3094&amp;h=1220&amp;f=jpeg&amp;s=326061" alt=""><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- My document --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Paragraph</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>原始文件里所有空白符都会在 DOM 中出现（不包括标签内含的空白符）<br><img src="https://user-gold-cdn.xitu.io/2018/8/5/165093ea635eda04?w=1476&amp;h=606&amp;f=png&amp;s=80032" alt=""></p><pre><code>* Document 造出了 document这个浏览器内置的对象，用于表示整个文档* Eelement 创造了 HTML的标签* Text 创建 页面中所有的文本* Node是Document,Elemetn,text 这三者的原型</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164eb6bd7feb96a4?w=3096&amp;h=1392&amp;f=jpeg&amp;s=331881" alt=""><br>DOM的作用就是将页面中的节点通过相应的构造函数，构造成对应的对象，保存在内存中</p><p>我们可以自己随便找个网站测试下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>)</span><br><span class="line"><span class="built_in">console</span>.dir(body)</span><br></pre></td></tr></table></figure></p><p>沿着body的原型链你会发现 body的原型链是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body--&gt;HTMLBodyElement--&gt;HTMLElement--&gt;Element--&gt;Node</span><br></pre></td></tr></table></figure></p><h2 id="Node-的接口"><a href="#Node-的接口" class="headerlink" title="Node 的接口"></a>Node 的接口</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><a href="https://wangdoc.com/javascript/dom/node.html#nodeprototypenodename" target="_blank" rel="noopener">nodeName</a>/<a href="https://wangdoc.com/javascript/dom/node.html#nodeprototypenodetype" target="_blank" rel="noopener">nodeType</a>/nodeValue        : 节点名/节点类型/节点值</li><li>parentNode/parentElement           : 父节点/父元素节点</li><li>childNodes/firstChild/lastChild    : 所有子节点/第一个子节点/最后一个子节点(#Text)</li><li>nextSibling/previousSibling        ：兄弟节点(注意#Text)</li><li>innerText/textContent              ：节点内容</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165126a1db3df0c0?w=441&amp;h=263&amp;f=jpeg&amp;s=5880" alt=""></p><h3 id="方法（如果一个属性是函数，那么这个属性就也叫做方法；换言之，方法是函数属性）"><a href="#方法（如果一个属性是函数，那么这个属性就也叫做方法；换言之，方法是函数属性）" class="headerlink" title="方法（如果一个属性是函数，那么这个属性就也叫做方法；换言之，方法是函数属性）"></a>方法（如果一个属性是函数，那么这个属性就也叫做方法；换言之，方法是函数属性）</h3><p>appendChild()<br>cloneNode()<br>contains()<br>hasChildNodes()<br>insertBefore()<br>isEqualNode()<br>isSameNode()<br>removeChild()<br>replaceChild()<br>normalize()</p><p> <strong>Node的六个注意事项</strong></p><ul><li>1 nextSibling/previousSibling 可能会获取到文本节点</li><li>2 innerText/textContent 是有些微区别的</li><li>3 nodeType记住 1代表Element 3代表Text</li><li>4 <a href="https://wangdoc.com/javascript/dom/node.html#nodeprototypeclonenode" target="_blank" rel="noopener">cloneNode</a>（deep） 是分为深/浅 拷贝的 deep:true/false</li><li>5 isEqualNode()/isSameNode()<a href="https://wangdoc.com/javascript/dom/node.html#nodeprototypeisequalnode%EF%BC%8Cnodeprototypeissamenode" target="_blank" rel="noopener">的区别</a></li><li>6 normalize()是什么意思</li></ul><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p>document对象是文档的根节点，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用</p><p>着重介绍两个方法：<br>    document.querySelector()，document.querySelectorAll()</p><pre><code>document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回nulldocument.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是DOM&quot;&gt;&lt;a href=&quot;#什么是DOM&quot; class=&quot;headerlink&quot; title=&quot;什么是DOM&quot;&gt;&lt;/a&gt;什么是DOM&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;* DOM是js操作网页的接口
* DOM是一棵由node节点构成的树
* DOM(Docu
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript之—__proto__和prototype</title>
    <link href="http://yoursite.com/2018/08/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2018/08/25/原型链/</id>
    <published>2018-08-25T06:55:11.000Z</published>
    <updated>2018-08-26T03:31:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h2><p> javascript提供了一些全局函数如 Number()、String()、Boolean()、Object()等<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两者有和区别呢？</span></span><br><span class="line"><span class="keyword">var</span> n1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n2 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//区别点：n1 和 n2 的内存图不一样</span></span><br><span class="line"><span class="comment">//n2是一个对象，对象内有Number提供的api供内使用，而n1只是一个基本类型的number</span></span><br><span class="line">n2.toString() <span class="comment">// "1"</span></span><br><span class="line"><span class="keyword">typeof</span> n1 === <span class="string">"number"</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> n2 === <span class="string">"object"</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16477f342d3017d6?w=1966&amp;h=864&amp;f=jpeg&amp;s=81293" alt=""><br>为什么 n1.toString() 也能使用?<br>Javascript中三种原始类型的值——数值、字符串、布尔值分别有其相应的<a href="http://javascript.ruanyifeng.com/stdlib/wrapper.html" target="_blank" rel="noopener">“包装对象”</a>，在一定条件下，原始类型会自动转为对象。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/164780b130eda3e4?w=2128&amp;h=860&amp;f=jpeg&amp;s=205003" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16478163b1fb7935?w=1532&amp;h=694&amp;f=jpeg&amp;s=143256" alt=""></p><h2 id="共用属性"><a href="#共用属性" class="headerlink" title="共用属性"></a>共用属性</h2><p>对象是由构造函数生成的，同一个构造函数生成的不同实例对象共享一些属性(公用属性)<br>var 实例对象 = new 构造函数()</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16478ac25fd411e2?w=3800&amp;h=1610&amp;f=jpeg&amp;s=649793" alt=""></p><p>每一个实例对象都有一个<strong>proto</strong>属性，它指向的是构造它的函数的prototype属性，该属性保存着该类对象所共享的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.__proto__ === <span class="built_in">Number</span>.prototype</span><br><span class="line">s.__proto__ === <span class="built_in">String</span>.prototype</span><br><span class="line">b.__proto__ === <span class="built_in">Boolean</span>.prototype</span><br><span class="line">o.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><h3 id="浏览器为我们做了一些事情"><a href="#浏览器为我们做了一些事情" class="headerlink" title="浏览器为我们做了一些事情"></a>浏览器为我们做了一些事情</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16478b42b26b1b6d?w=3086&amp;h=1592&amp;f=jpeg&amp;s=237887" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/7/8/16478aee240132ad?w=3330&amp;h=1698&amp;f=jpeg&amp;s=249685" alt=""><br>Object.prototype Number.prototype String.prototype Boolean.prototype 是由浏览器事先提供好的</p><p>你只需要通过 var s = new String(‘123’)就完成了 s的所有api绑定 </p><h3 id="proto-和-prototype"><a href="#proto-和-prototype" class="headerlink" title="proto 和 prototype"></a><strong>proto</strong> 和 prototype</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16478b6353b9c219?w=2060&amp;h=1746&amp;f=jpeg&amp;s=264820" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全局函数&quot;&gt;&lt;a href=&quot;#全局函数&quot; class=&quot;headerlink&quot; title=&quot;全局函数&quot;&gt;&lt;/a&gt;全局函数&lt;/h2&gt;&lt;p&gt; javascript提供了一些全局函数如 Number()、String()、Boolean()、Object()等&lt;br
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
</feed>
